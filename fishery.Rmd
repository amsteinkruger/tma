---
title: "Fishery Model"
date: "`r Sys.Date()`"
output: html_document
---

##### Packages

Options for installation and updates are hashed out. Packages are checked out in a batch through lapply().

gg3d - a package for graphics in 3 dimensions - requires installation from Github through devtools.

If you're interested in a better option for package handling, learning packrat would be neat, but hasn't paid off so far.

```{r pkg_ins, echo = TRUE, warning = FALSE, message = FALSE}

rm(list=ls())

# Check out knitr for knitr::read_chunk.
library(knitr)

# Name packages.
pkg <- c("readr",
         "knitr",
         "tidyverse",
         "gapminder",
         "sandwich",
         "broom",
         "stargazer",
         "cowplot",
         "kableExtra",
         "reshape2",
         "devtools")

# Install packages.
#install.packages(pkg, verbose = FALSE, quiet = TRUE)
#devtools::install_github("AckerDWM/gg3D")
  
# Update packages.
#update.packages(pkg, verbose = FALSE, quiet = TRUE)

# Check out packages.
lapply(pkg, library, character.only = TRUE)

#library(gg3D)

```

####Objective: Step through optimal aggregate harvest in an open access fishery.
1. Build a toy model for tests and demos.
2. Replicate INAPESCA's population model. 
3. Adapt methods to a 10-year forecast.
4. Add price-sensitive effort under open access.
5. Parameterize the model over historic recruitment, stock, and catch data.


##### 1. Toy Model

```{r age_struct_toy, eval = FALSE}

# Build a matrix to fill.
# Matrix of numbers at age by year.
mat_a = matrix(nrow = 10, ncol = 5)

# Vector for initial numbers at age.
v_init = seq(5, 1)

# Vectors for proportional mortalities by age. NB: Survival, not mortality.
v_mort_first = 0.5
v_mort_rest = c(0.85, 0.875, 0.90, 1)

# Vector for proportional fecundities at age. Each fecund fish returns two fish. 
v_fec_rest = rep(0.25, 4)

# Plug initial numbers into the matrix.
mat_a[1,] = v_init

# Run one-shot test.
mat_a[2, 2:5] = mat_a[1, 1:4] * v_mort_rest
mat_a[2, 1] = sum(mat_a[1, 2:5] * v_fec_rest * 3)

# Set up first test.
fun_test = function(nrow, ncol){mat_a = matrix(nrow = nrow, ncol = ncol)
                                v_init = seq(5, 1)
                                v_mort_first = 0.5
                                v_mort_rest = c(0.85, 0.875, 0.90, 1)
                                v_fec_rest = rep(0.25, 4)
                                mat_a[1,] = v_init
                                for(i in 2:nrow){mat_a[i, 2:5] = mat_a[i - 1, 1:4] * v_mort_rest
                                                 mat_a[i, 1] = sum(mat_a[i - 1, 2:5] * v_fec_rest * 3)/(1 + mat_a[i - 1, 1] / 250)}
                                  
                                return(mat_a)}

# Run first test.
uh = fun_test(50, 5)

# Reshape data for easier plotting.
duh = data.frame(uh)

mut = mutate(duh, t = seq(0, 49))

melt = reshape2::melt(mut, id.vars = "t")

# Plot in two dimensions.
toy_plot = 
ggplot(melt, aes(t, value, color = variable)) +
  geom_line()

print(toy_plot)

# Plot in three dimensions. WHY IS THIS SO BROKEN
#toy_plot3 = 
#ggplot(melt, aes(x = variable, z = t, y = value, color = variable)) +
#  ggtitle("Toy Stock") +
#  theme_void() + 
#  theme(legend.position = "none") +
#  axes_3D() +
#  stat_3D(geom = "point", phi = 90, theta = 270) +
#  scale_color_brewer(palette = "RdBu")

```

##### 1. Totoaba Model

 * Each component requires specification of a function from available data and existing models.
  + Right now, each component is specified as a vector, which is convenient but not adequate for what we're doing.
  + Turning everything into functions, or keeping things as functions instead of vectors, is the next step for more complex loops.

* Build a matrix of numbers at age by year.

```{r age_struct_tma_mat}

# Matrix of numbers at age by year.
mat_a = matrix(nrow = 50, ncol = 27)

```

* Build an initial age structure - numbers at age - for the population, using INAPESCA's lower estimate for 2017 biomass and True's function for a stable age structure.
+ Consider testing True's function against a longer simulation.
+ PUT YOUR LATEX FUNCTIONS FOR TRUE'S FUNCTION IN HERE

```{r age_struct_tma_ninit}

# Vector for initial n at a.
#  Assign initial biomass from INAPESCA estimate.
#  Try the lower bound on the 95% CI of INAPESCA's 2017 estimate from surveys.
biomass_init = 25709000 # kilograms.

#  Assign functional form for frequencies at age from True (2018). See notes on symposium presentation. Check whether curve describes numbers at age.
#fun_a_n = function(a){121.99 * 10 ^ (-0.214 * a)}
# Alternative distribution for tests.
fun_a_n = function(a){121.99 * 10 ^ (-0.05 * a)}

#  Convert numbers at age to sums of weights at age to work from total biomass back to numbers at age.
fun_a_l = function(a, linf, k, t0){l = linf * (1 - exp(-k * (a - t0)))} # INAPESCA (2018): 200, 0.155, -0.65. See notes for alternatives.
fun_l_w = function(a, l, b){w = a * l ^ b} # INAPESCA (2018) / Anda-Monta単ez et al. (2013): 0.000005, 3.0635. See notes for alternatives.

# Calculations:
#  Vector of ages.
a = seq(0, 26)
#  Vector of lengths.
l = fun_a_l(a, 200, 0.155, -0.65)
#  Vector of weights.
#w = fun_l_w(0.000005, l, 3.0635) This is a wrong thing that makes your numbers bad and wrong.
w = fun_l_w(0.000004128, l, 3.24674) # This is a right thing that makes your numbers good and right.
#  Numbers at age.
afreq = fun_a_n(a)
#  Weights at age.
wfreq = afreq * w
#  Weights at age, but useful.
winit = wfreq * (1 / sum(wfreq)) * biomass_init
#  Numbers at age to seed the model. That wasn't so hard, right?
ninit = winit / w
plot(ninit)

```

* Build survival (i.e. 1 - F) at age. It's constant, so it's not really exciting.
+ PUT THAT LATEX FUNCTION THAT RETURNS A CONSTANT MORTALITY IN HERE

```{r age_struct_tma_natmort}

# Vector for proportional natural mortalities at age. NB: Survival, not mortality. From INAPESCA (2018) / Cisneros-Mata et al. (1995).
v_mort = rep(0.78, 27)

```

* Build poaching mortalities at age from INAPESCA data. 
+ Instead of using numbers from 2016 - 2017, sums by age are taken over all years of sampling for a higher *n*.
+ Whether this is the best option is open to debate and guidance from advisors.
+ The function fit to mortalities-at-age is a Weibull probability density function. Others might work better. This one was chosen from eyeballing and Google.
+ PUT YOUR LATEX FUNCTIONS IN HERE

```{r age_struct_tma_fismort}
# Vector for proportional poaching mortalities at age.
#  Read in values for size-selective poaching from INAPESCA (2018); n = 1147 from 9 periods, 1963 - 2017.
v_select_data = 
  c(6, 9, 15, 60, 191, 281, 165, 133, 82, 33, 27, 21, 17, 10, 12, 16, 8, 15, 9, 12, 7, 9, 5, 2, 2, 0) %>% 
  data.frame() %>% 
  mutate(age = seq(1, 26)) %>% 
  rename(n = ".")

#  Estimate fit for a Weibull probability density function, because the internet said so. Try weibull.com/hotwire/issue14/relbasics14.htm
nls_select = nls(v_select_data$n ~ ifelse(is.na(x * (a / b) * ((v_select_data$age - c) / b) ^ (a - 1) * exp(-((v_select_data$age - c) / b ) ^ a)),
                                          0,
                                          x * (a / b) * ((v_select_data$age - c) / b) ^ (a - 1) * exp(-((v_select_data$age - c) / b ) ^ a)),
                 v_select_data, 
                 start = list(x = 3000, a = 2.5, b = 10, c = -3), 
                 lower = list(0, 0, 0, -Inf),
                 algorithm = "port")

#  Tibbulate nonlinear estimation.
nls_tidy = tidy(nls_select)

#  Plot fit against actual values.
fun_select = function(x, a, b, c, t){n = ifelse(is.na(x * (a / b) * ((t - c) / b) ^ (a - 1) * exp(-((t - c) / b ) ^ a)),
                                                0,
                                                x * (a / b) * ((t - c) / b) ^ (a - 1) * exp(-((t - c) / b ) ^ a))
                                     return(n)}

v_select_fit = fun_select(nls_tidy$estimate[1], nls_tidy$estimate[2], nls_tidy$estimate[3], nls_tidy$estimate[4], seq(1, 26))

ggplot() + 
  geom_point(aes(seq(1, 26), v_select_fit), color = "Red") + 
  geom_point(aes(seq(1, 26), v_select_data$n), color = "Green")

#  Consider fixing the upper tail. Those residuals probably matter.

#  Use parameters to restate the function on a single dimension (age) for integration.
simple_fun_select = function(t){n = 
                                ifelse(is.na(nls_tidy$estimate[1] * (nls_tidy$estimate[2] / nls_tidy$estimate[3]) * ((t - nls_tidy$estimate[4]) / nls_tidy$estimate[3]) ^ (nls_tidy$estimate[2] - 1) * exp(-((t - nls_tidy$estimate[4]) / nls_tidy$estimate[3] ) ^ nls_tidy$estimate[2])),
                                0,
                                nls_tidy$estimate[1] * (nls_tidy$estimate[2] / nls_tidy$estimate[3]) * ((t - nls_tidy$estimate[4]) / nls_tidy$estimate[3]) ^ (nls_tidy$estimate[2] - 1) * exp(-((t - nls_tidy$estimate[4]) / nls_tidy$estimate[3] ) ^ nls_tidy$estimate[2]))
                                return(n)}

#  Integrate over ages of interest. Those should probably be a universal parameter at this point. Consider fixing.
int_select = integrate(simple_fun_select, lower = 0, upper = 29)

#  Transform fitted values for poaching selectivity into a probability distribution function using the integral of the unidimensional function.
v_select_pdf = fun_select(nls_tidy$estimate[1], nls_tidy$estimate[2], nls_tidy$estimate[3], nls_tidy$estimate[4], seq(0, 29)) * 1 / int_select$value

#  Transform 2017 catch into 2017 catch-at-age in weight, then transform that sucker into catch-at-age in numbers, then make it proportions again.
#  Make this comment better.
catch = 1400000 # kilograms from tonnes. INAPESCA (2018).
v_select_n = catch * v_select_pdf / w # Check your conversion! You did this in the middle of the night, check it!
v_select_use = v_select_n/ninit # Diagnostic plot indicates you should really, really fix the residuals on the selectivity estimation.

```

* Build bycatch mortalities at age from INAPESCA data.
+ These are proportions at age, but since INAPESCA's data is a narrow spread around one year of age, it's easiest to just make bycatch a proportion of juveniles at one age.
+ This needs fixing if we increase resolution to months.

```{r age_struct_tma_bycmort}

# Value for proportional bycatch mortalities at age.
bymort_init = 80000 # INAPESCA (2018) - estimated for 2011 - 2017 by some sort of credible method, probably.
bymort = 1 - bymort_init / ninit[2] # Instead of distributing bycatch mortalities, we concentrate them on one age (1) for lack of length-at-age resolution.

```

* Build proportional fecundities at age from INAPESCA estimates of maturation and egg production by weight.
+ PUT YOUR LATEX FUNCTIONS IN HERE

```{r age_struct_tma_fec}

# Vector for proportional fecundities at age. From INAPESCA (2018) / Valenzuela-Qui単onez (2014).
#  Set function.
fun_fec = function(l){1 / ( 1 + exp(-0.0099 * ((l - 1333.31) * 10)))}
#  Transform vector of lengths at age to fecundities.
v_fec = fun_fec(l)

# Vector for production of fecund hembras at age by way of length.
#  Set function for eggs per kilogram of total weight of mature fish.
fun_eggs = function(l){221.76 * exp(0.0047 * l)} # Valenzuela-Qui単onez (2014); used with Anda-Monta単ez et al. (2013) for mean by INAPESCA (2018).

#  Get values corresponding to vector of lengths.
v_eggs_l = fun_eggs(l)

#  Get values corresponding to vector of weights - this works out to be egg production at age before accounting for maturation.
v_eggs_w = v_eggs_l * w

# So account for maturation and survival, dummy. Survival from egg to juvenile from INAPESCA (2018). Reference against True (2018).
v_eggs_surv = 0.3 * 0.9 * 0.95 * 0.1 # Corrective factor of 100 - fix w/ optimization.
v_eggs = v_eggs_w * v_fec * v_eggs_surv

```

* Model w/ vectors, not functions.

```{r age_struct_tma_ENTER_THE_MATRIX}
# Plug initial numbers into the matrix.
mat_a[1,] = ninit

# Set up first test.
fun_test = function(nrow, ncol, ninit, v_mort, bymort, v_select_use, v_eggs, k){
                                mat_a = matrix(nrow = nrow, ncol = ncol)
                                mat_a[1,] = ninit
                                for(i in 2:nrow){mat_a[i, 3:27] = mat_a[i - 1, 2:26] * v_mort[3:27] * (1 - v_select_use[3:27])
                                                 mat_a[i, 2] = mat_a[i - 1, 2] * v_mort[2] * bymort * (1 - v_select_use[2])
                                                 mat_a[i, 1] = sum(mat_a[i - 1, 1:27] * v_eggs)/(1 + mat_a[i - 1, 1] / k)}
                                  
                                return(mat_a)}

```

* Run your runs.

```{r age_struct_tma_run}

# Run first test.
uh = fun_test(10, 27, ninit, v_mort, bymort, v_select_use, v_eggs, 5000000)
vh = fun_test(10, 27, ninit, v_mort, bymort, v_select_use * 0, v_eggs, 5000000)

wuh = sweep(uh, MARGIN = 2, w, '*')
wvh = sweep(vh, MARGIN = 2, w, '*')

```

* Plot your runs.

```{r age_struct_tma_ploots}

# Using weights! Weights, not numbers!
# Reshape for a basic plot.
duh = data.frame(uh) %>% 
  mutate(t = seq(0, 9)) %>% 
  melt(id.vars = "t")

# Plot.
try_age =
ggplot(duh, aes(t, value, color = variable)) +
  geom_line()

# Reshape and fiddle for a presentable plot.
muh = data.frame(wuh) %>% 
  mutate(t = seq(2020, 2029)) %>% 
  melt(id.vars = "t") %>%
  group_by(t) %>% 
  summarise(s = sum(value)) %>% 
  mutate(s = s * 0.001) %>% 
  mutate(t = t - 3)

# Ditto, but for the counterfactual plot.
vuh = data.frame(wvh) %>% 
  mutate(t = seq(2020, 2029)) %>% 
  melt(id.vars = "t") %>%
  group_by(t) %>% 
  summarise(s = sum(value)) %>% 
  mutate(s = s * 0.001) %>% 
  mutate(t = t - 3)

# Theming chunk.
btheme =  theme(plot.title = element_text(hjust = 0.5, size = 32, family = "Century Gothic", face = "bold"), 
          rect = element_rect(fill = "transparent"),
          plot.background = element_rect(fill = "transparent", color = NA),
          legend.position = "right",
          legend.background = element_rect(fill = "transparent"),
          legend.box.background = element_rect(fill = "transparent"),
          legend.key = element_rect(fill="transparent", colour=NA),
          legend.text = element_text(size = 16, family = "Century Gothic"),
          legend.title = element_text(size = 18, family = "Century Gothic"),
          panel.background = element_rect(fill = "transparent"),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          axis.text.x = element_text(size = 18, family = "Century Gothic"),
          axis.title.x = element_text(size = 24, family = "Century Gothic", face = "bold"),
          axis.text.y = element_text(size = 18, family = "Century Gothic"),
          axis.title.y = element_text(size = 24, family = "Century Gothic", face = "bold"))

# Presentable plot.
try_sum = 
ggplot(muh, aes(t, s)) +
  geom_segment(aes(x = -Inf, xend = Inf, y = 4000, yend = 4000), linetype = "dashed") +
  geom_segment(aes(x = -Inf, xend = Inf, y = 2500, yend = 2500), linetype = "dashed") +
  #annotate("text", x = 2019.1, y = 4300, label = "Target Biomass", size = 8, family = "Century Gothic") +
  #annotate("text", x = 2020, y = 2800, label = "Minimum Viable Biomass", size = 8, family = "Century Gothic") +
  geom_line(size = 3, color = "#1F4E79") +
  #scale_x_continuous(expand = c(0, 0.225), limits = c(2017, 2026), breaks = c(2017, 2026)) +
  #scale_y_continuous(expand = c(0, 0), limits = c(0, 10000), labels = scales::comma) +
  #ggtitle("Stock Forecast, 2017 - 2027") +
  labs(x = "Years", y = "Tonnes of Biomass") +
  theme_classic() +
  btheme

# Save.
ggsave("fishy.png", 
       width = 720, 
       height = 490,
       dpi = 300, 
       device = png, 
       limitsize = FALSE, 
       bg = "transparent")

huh = left_join(muh, vuh, by = "t")

try_hum = 
ggplot(huh) +
  geom_ribbon(aes(t, ymin = s.x, ymax = s.y), fill = "#F4B183", alpha = 0.50) +
  geom_line(aes(t, s.y), color = "#F4B183", size = 3) +
  geom_line(aes(t, s.x), color = "#1F4E79", size = 3) +
  #annotate("text", x = 2019.1, y = 4300, label = "Target Biomass", size = 8, family = "Century Gothic") +
  #annotate("text", x = 2020, y = 2800, label = "Minimum Viable Biomass", size = 8, family = "Century Gothic") +
  geom_segment(aes(x = -Inf, xend = 2026, y = 4000, yend = 4000), linetype = "dashed") +
  geom_segment(aes(x = -Inf, xend = 2026, y = 2500, yend = 2500), linetype = "dashed") +
  #scale_x_continuous(expand = c(0, 0.225), limits = c(2017, 2026), breaks = c(2017, 2026)) +
  #scale_y_continuous(expand = c(0, 0), limits = c(0, 10000), labels = scales::comma) +
  #ggtitle("Stock Forecast, 2017 - 2027") +
  labs(x = "Years", y = "Tonnes of Biomass") +
  theme_classic() +
  btheme

ggsave("fishier.png", 
       width = 720, 
       height = 490,
       dpi = 300, 
       device = png, 
       limitsize = FALSE, 
       bg = "transparent")

```

```{r otherploots}
melt$variable = str_remove(melt$variable, "X")
melt$variable = as.numeric(melt$variable)

try3 = 
ggplot(melt, aes(x = variable, z = value, y = t, color = variable)) +
  ggtitle("Numbers at Age for 25 Years, Ages 1 - 30") +
  theme_void() + 
  theme(legend.position = "none") +
  #axes_3D() + 
  stat_3D(geom = "point", phi = 45, theta = 135) +
  scale_color_distiller(palette = "RdBu")

tryfirst = 
ggplot(filter(melt, variable == 1), aes(x = variable, z = value, y = t, color = variable)) +
  ggtitle("Numbers at Age for 25 Years, Ages 1 - 30") +
  theme_void() + 
  theme(legend.position = "none") +
  #axes_3D() + 
  stat_3D(geom = "point", phi = 45, theta = 135) +
  scale_color_distiller(palette = "RdBu")

trysecond = 
ggplot(filter(melt, variable < 11 & variable > 1), aes(x = variable, z = value, y = t, color = variable)) +
  ggtitle("Numbers at Age for 25 Years, Ages 2 - 10") +
  theme_void() + 
  theme(legend.position = "none",
        plot.title = element_text(size = 8)) +
  #axes_3D() + 
  stat_3D(geom = "point", phi = 45, theta = 135) +
  scale_color_distiller(palette = "Purples")

trythird = 
ggplot(filter(melt, variable < 21 & variable > 10), aes(x = variable, z = value, y = t, color = variable)) +
  ggtitle("Numbers at Age for 25 Years, Ages 11 - 20") +
  theme_void() + 
  theme(legend.position = "none",
        plot.title = element_text(size = 8)) +
  #axes_3D() + 
  stat_3D(geom = "point", phi = 45, theta = 135) +
  scale_color_distiller(palette = "Reds")

tryfourth = 
ggplot(filter(melt, variable < 31 & variable > 20), aes(x = variable, z = value, y = t, color = variable)) +
  ggtitle("Numbers at Age for 25 Years, Ages 21 - 30") +
  theme_void() + 
  theme(legend.position = "none",
        plot.title = element_text(size = 8)) +
  #axes_3D() + 
  stat_3D(geom = "point", phi = 45, theta = 135) +
  scale_color_distiller(palette = "Oranges")

ggsave("f1plot.png", plot = trysecond, dpi = 300, width = 3.25, height = 4.5)
ggsave("f2plot.png", plot = trythird, dpi = 300, width = 3.25, height = 4.5)
ggsave("f3plot.png", plot = tryfourth, dpi = 300, width = 3.25, height = 4.5)

```

